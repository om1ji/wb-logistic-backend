import asyncio
import logging
import os
from typing import Dict, List, Optional, Union

from aiogram import Bot, Dispatcher
from aiogram.filters import CommandStart
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, Message
from dotenv import load_dotenv
from flask import Flask, request, jsonify

from handlers import callbacks, commands
from handlers.callbacks import router as callbacks_router

load_dotenv()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_GROUP_ID = os.getenv("TELEGRAM_GROUP_ID")
WB_BACKEND_URL = os.getenv("WB_BACKEND_URL", "http://localhost:8000")

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
if not TELEGRAM_BOT_TOKEN:
    logger.error("TELEGRAM_BOT_TOKEN not set")
    exit(1)
if not TELEGRAM_GROUP_ID:
    logger.error("TELEGRAM_GROUP_ID not set")
    exit(1)

bot = Bot(token=TELEGRAM_BOT_TOKEN)
group = TELEGRAM_GROUP_ID
dp = Dispatcher()

callbacks_router.bot = bot

dp.include_router(callbacks_router)
dp.include_router(commands.router)

# –ó–∞–º–µ–Ω—è–µ–º FastAPI –Ω–∞ Flask
app = Flask(__name__)

def message_builder(order_data: Dict) -> Dict[str, Union[str, InlineKeyboardMarkup]]:
    """
    Builds a message for Telegram notification with inline keyboard
    """
    print(order_data)
    try:
        message_parts = []
        
        message_parts.append(f"üì¶ –ù–æ–≤—ã–π –∑–∞–∫–∞–∑ #{order_data.get('sequence_number', 'N/A')}")
        
        if warehouse := order_data.get('warehouse_name'):
            message_parts.append(f"\nüè≠ –°–∫–ª–∞–¥: {warehouse}")

        # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≥—Ä—É–∑–µ
        cargo_info = []
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≥—Ä—É–∑–µ –∏–∑ –Ω–æ–≤–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
        cargo_data = order_data.get('cargo_info', {})
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–æ—Ä–æ–±–∫–∏
        boxes = cargo_data.get('boxes', {})
        box_count = boxes.get('count')
        if box_count and int(box_count) > 0:
            cargo_info.append(f"üì¶ –ö–æ—Ä–æ–±–∫–∏:")
            cargo_info.append(f"‚Ä¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {box_count}")
            
            # –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Ä–∞–∑–º–µ—Ä
            box_type = boxes.get('container_type')
            if box_type and box_type != "–î—Ä—É–≥–æ–π —Ä–∞–∑–º–µ—Ä":
                cargo_info.append(f"‚Ä¢ –†–∞–∑–º–µ—Ä: {box_type}")
            # –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω –∫–∞—Å—Ç–æ–º–Ω—ã–π —Ä–∞–∑–º–µ—Ä, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã
            else:
                dimensions = boxes.get('dimensions', {})
                length = dimensions.get('length')
                width = dimensions.get('width')
                height = dimensions.get('height')
                if length and width and height:
                    cargo_info.append(f"‚Ä¢ –†–∞–∑–º–µ—Ä—ã (–î√ó–®√ó–í): {length}√ó{width}√ó{height} —Å–º")
                
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–∞–ª–ª–µ—Ç—ã
        pallets = cargo_data.get('pallets', {})
        pallet_count = pallets.get('count')
        if pallet_count and int(pallet_count) > 0:
            cargo_info.append(f"üîß –ü–∞–ª–ª–µ—Ç—ã:")
            cargo_info.append(f"‚Ä¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {pallet_count}")
            
            # –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è –≤–µ—Å–∞
            pallet_type = pallets.get('container_type')
            if pallet_type and pallet_type != "–î—Ä—É–≥–æ–π –≤–µ—Å":
                cargo_info.append(f"‚Ä¢ –ö–∞—Ç–µ–≥–æ—Ä–∏—è –≤–µ—Å–∞: {pallet_type}")
            # –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω –∫–∞—Å—Ç–æ–º–Ω—ã–π –≤–µ—Å, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –µ–≥–æ
            else:
                if weight := pallets.get('weight'):
                    cargo_info.append(f"‚Ä¢ –í–µ—Å: {weight} –∫–≥")
        
        # –ï—Å–ª–∏ –µ—Å—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≥—Ä—É–∑–µ, –¥–æ–±–∞–≤–ª—è–µ–º –µ—ë –≤ —Å–æ–æ–±—â–µ–Ω–∏–µ
        if cargo_info:
            message_parts.append("\n" + "\n".join(cargo_info))

        if services := order_data.get('additional_services', []):
            services_info = []
            for service in services:
                if name := service.get('name'):
                    price = service.get('price', 0)
                    services_info.append(f"‚Ä¢ {name}: {price} ‚ÇΩ")
            if services_info:
                message_parts.append("\nüõ† –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —É—Å–ª—É–≥–∏:\n" + "\n".join(services_info))

        company_info = []
        if company := order_data.get('company_name'):
            company_info.append(f"üè¢ –ö–æ–º–ø–∞–Ω–∏—è: {company}")
        if contact := order_data.get('client_name'):
            company_info.append(f"üë§ –ö–æ–Ω—Ç–∞–∫—Ç–Ω–æ–µ –ª–∏—Ü–æ: {contact}")
        if phone := order_data.get('client_phone'):
            company_info.append(f"üì± –¢–µ–ª–µ—Ñ–æ–Ω: {phone}")

        if company_info:
            message_parts.append("\n" + "\n".join(company_info))

        pickup_address = order_data.get('pickup_address')
        if pickup_address != "" and pickup_address != "–ù–µ —É–∫–∞–∑–∞–Ω":
            message_parts.append(f"\nüìç –ê–¥—Ä–µ—Å –∑–∞–±–æ—Ä–∞ –≥—Ä—É–∑–∞:\n{pickup_address}")

        if total_cost := order_data.get('cost'):
            message_parts.append(f"\nüí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å: {total_cost} ‚ÇΩ")

        keyboard = InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    InlineKeyboardButton(
                        text="‚úÖ –ü—Ä–∏–Ω—è—Ç—å",
                        callback_data=f"order_accept_{order_data.get('order_id')}"
                    ),
                    InlineKeyboardButton(
                        text="‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å",
                        callback_data=f"order_reject_{order_data.get('order_id')}"
                    )
                ]
            ]
        )

        return {
            "text": "\n".join(message_parts),
            "reply_markup": keyboard
        }
    except Exception as e:
        logger.error(f"Error building message: {e}")
        return {
            "text": "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è",
            "reply_markup": None
        }


@dp.message(CommandStart())
async def command_start_handler(message: Message) -> None:
    await message.answer(
        f"–ü—Ä–∏–≤–µ—Ç, {message.from_user.full_name}! –Ø –±–æ—Ç –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞–º–∏."
    )


async def send_notification(chat_id: Union[str, int], order_data: Dict) -> None:
    """
    Sends notification about new order to specified chat
    """
    try:
        message = message_builder(order_data)
        await bot.send_message(
            chat_id=chat_id,
            text=message["text"],
            reply_markup=message["reply_markup"]
        )
    except Exception as e:
        logger.error(f"Error sending notification: {e}")


# –ó–∞–º–µ–Ω—è–µ–º FastAPI-—Ä–æ—É—Ç –Ω–∞ Flask-—Ä–æ—É—Ç
@app.route("/api/send_notification", methods=["POST"])
def send_notification_endpoint():
    try:
        order_data = request.json
        
        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π event loop –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞ –∏–∑ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –∫–æ–¥–∞ Flask
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(send_notification(group, order_data))
        
        return jsonify({"status": "success"})
    except Exception as e:
        logging.error(f"Error sending notification: {str(e)}")
        return jsonify({"status": "error", "message": str(e)}), 500


# –ó–∞–º–µ–Ω—è–µ–º FastAPI health check –Ω–∞ Flask-—Ä–æ—É—Ç
@app.route("/health", methods=["GET"])
def health_check():
    return jsonify({"status": "ok"})


# –§—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ Flask-—Å–µ—Ä–≤–µ—Ä–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
def run_flask():
    app.run(host="0.0.0.0", port=8080)


async def main() -> None:
    try:
        # –í—ã–≤–æ–¥–∏–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö
        logger.info(f"Starting Telegram bot with group ID: {group}")
        logger.info(f"WB_BACKEND_URL: {WB_BACKEND_URL}")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞ –∏ —Å–µ—Ä–≤–µ—Ä –≤ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –∑–∞–¥–∞—á–∞—Ö
        bot_task = asyncio.create_task(dp.start_polling(bot))
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º Flask –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        import threading
        flask_thread = threading.Thread(target=run_flask)
        flask_thread.daemon = True
        flask_thread.start()
        
        # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏ –±–æ—Ç–∞
        await bot_task
    except (KeyboardInterrupt, asyncio.CancelledError):
        logger.info("Stopping bot and server...")
    finally:
        # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ –±–æ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –∑–∞–≤–µ—Ä—à–∏–ª —Ä–∞–±–æ—Ç—É
        await dp.stop_polling()
        logger.info("Bot and server stopped")


if __name__ == "__main__":
    asyncio.run(main())
